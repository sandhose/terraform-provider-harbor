// Code generated by go-swagger; DO NOT EDIT.

package products

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new products API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for products API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteLabelsID deletes the label specified by ID

Delete the label specified by ID.

*/
func (a *Client) DeleteLabelsID(params *DeleteLabelsIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLabelsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLabelsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteLabelsID",
		Method:             "DELETE",
		PathPattern:        "/labels/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteLabelsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteLabelsIDOK), nil

}

/*
DeleteProjectsProjectID deletes project by project ID

This endpoint is aimed to delete project by project ID.

*/
func (a *Client) DeleteProjectsProjectID(params *DeleteProjectsProjectIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteProjectsProjectIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteProjectsProjectIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteProjectsProjectID",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectsProjectIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteProjectsProjectIDOK), nil

}

/*
DeleteProjectsProjectIDMembersMid deletes project member
*/
func (a *Client) DeleteProjectsProjectIDMembersMid(params *DeleteProjectsProjectIDMembersMidParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteProjectsProjectIDMembersMidOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteProjectsProjectIDMembersMidParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteProjectsProjectIDMembersMid",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_id}/members/{mid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectsProjectIDMembersMidReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteProjectsProjectIDMembersMidOK), nil

}

/*
DeleteProjectsProjectIDMetadatasMetaName deletes metadata of a project

This endpoint is aimed to delete metadata of a project.

*/
func (a *Client) DeleteProjectsProjectIDMetadatasMetaName(params *DeleteProjectsProjectIDMetadatasMetaNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteProjectsProjectIDMetadatasMetaNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteProjectsProjectIDMetadatasMetaNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteProjectsProjectIDMetadatasMetaName",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_id}/metadatas/{meta_name}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectsProjectIDMetadatasMetaNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteProjectsProjectIDMetadatasMetaNameOK), nil

}

/*
DeleteProjectsProjectIDWebhookPoliciesPolicyID deletes webhook policy of a project

This endpoint is aimed to delete webhookpolicy of a project.

*/
func (a *Client) DeleteProjectsProjectIDWebhookPoliciesPolicyID(params *DeleteProjectsProjectIDWebhookPoliciesPolicyIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteProjectsProjectIDWebhookPoliciesPolicyIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteProjectsProjectIDWebhookPoliciesPolicyIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteProjectsProjectIDWebhookPoliciesPolicyID",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_id}/webhook/policies/{policy_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectsProjectIDWebhookPoliciesPolicyIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteProjectsProjectIDWebhookPoliciesPolicyIDOK), nil

}

/*
DeleteRegistriesID deletes specific registry

This endpoint is for to delete specific registry.

*/
func (a *Client) DeleteRegistriesID(params *DeleteRegistriesIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRegistriesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRegistriesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRegistriesID",
		Method:             "DELETE",
		PathPattern:        "/registries/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRegistriesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRegistriesIDOK), nil

}

/*
DeleteReplicationPoliciesID deletes the replication policy specified by ID

Delete the replication policy specified by ID.

*/
func (a *Client) DeleteReplicationPoliciesID(params *DeleteReplicationPoliciesIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteReplicationPoliciesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteReplicationPoliciesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteReplicationPoliciesID",
		Method:             "DELETE",
		PathPattern:        "/replication/policies/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteReplicationPoliciesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteReplicationPoliciesIDOK), nil

}

/*
DeleteRepositoriesRepoName deletes a repository

This endpoint let user delete a repository with name.

*/
func (a *Client) DeleteRepositoriesRepoName(params *DeleteRepositoriesRepoNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesRepoNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesRepoNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesRepoName",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repo_name}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepositoriesRepoNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRepositoriesRepoNameOK), nil

}

/*
DeleteRepositoriesRepoNameLabelsLabelID deletes label from the repository

Delete the label from the repository specified by the repo_name.

*/
func (a *Client) DeleteRepositoriesRepoNameLabelsLabelID(params *DeleteRepositoriesRepoNameLabelsLabelIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesRepoNameLabelsLabelIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesRepoNameLabelsLabelIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesRepoNameLabelsLabelID",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repo_name}/labels/{label_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepositoriesRepoNameLabelsLabelIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRepositoriesRepoNameLabelsLabelIDOK), nil

}

/*
DeleteRepositoriesRepoNameTagsTag deletes a tag in a repository

This endpoint let user delete tags with repo name and tag.

*/
func (a *Client) DeleteRepositoriesRepoNameTagsTag(params *DeleteRepositoriesRepoNameTagsTagParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesRepoNameTagsTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesRepoNameTagsTagParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesRepoNameTagsTag",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepositoriesRepoNameTagsTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRepositoriesRepoNameTagsTagOK), nil

}

/*
DeleteRepositoriesRepoNameTagsTagLabelsLabelID deletes label from the image

Delete the label from the image specified by the repo_name and tag.

*/
func (a *Client) DeleteRepositoriesRepoNameTagsTagLabelsLabelID(params *DeleteRepositoriesRepoNameTagsTagLabelsLabelIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteRepositoriesRepoNameTagsTagLabelsLabelIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRepositoriesRepoNameTagsTagLabelsLabelIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteRepositoriesRepoNameTagsTagLabelsLabelID",
		Method:             "DELETE",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/labels/{label_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRepositoriesRepoNameTagsTagLabelsLabelIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRepositoriesRepoNameTagsTagLabelsLabelIDOK), nil

}

/*
DeleteUsergroupsGroupID deletes user group

Delete user group
*/
func (a *Client) DeleteUsergroupsGroupID(params *DeleteUsergroupsGroupIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUsergroupsGroupIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUsergroupsGroupIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteUsergroupsGroupID",
		Method:             "DELETE",
		PathPattern:        "/usergroups/{group_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteUsergroupsGroupIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteUsergroupsGroupIDOK), nil

}

/*
DeleteUsersUserID marks a registered user as be removed

This endpoint let administrator of Harbor mark a registered user as
be removed.It actually won't be deleted from DB.

*/
func (a *Client) DeleteUsersUserID(params *DeleteUsersUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteUsersUserIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteUsersUserIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteUsersUserID",
		Method:             "DELETE",
		PathPattern:        "/users/{user_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteUsersUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteUsersUserIDOK), nil

}

/*
GetConfigurations gets system configurations

This endpoint is for retrieving system configurations that only provides for admin user.

*/
func (a *Client) GetConfigurations(params *GetConfigurationsParams, authInfo runtime.ClientAuthInfoWriter) (*GetConfigurationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConfigurationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetConfigurations",
		Method:             "GET",
		PathPattern:        "/configurations",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConfigurationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConfigurationsOK), nil

}

/*
GetHealth healths check API

The endpoint returns the health stauts of the system.

*/
func (a *Client) GetHealth(params *GetHealthParams, authInfo runtime.ClientAuthInfoWriter) (*GetHealthOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHealthParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetHealth",
		Method:             "GET",
		PathPattern:        "/health",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetHealthReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHealthOK), nil

}

/*
GetLabels lists labels according to the query strings

This endpoint let user list labels by name, scope and project_id

*/
func (a *Client) GetLabels(params *GetLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*GetLabelsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLabels",
		Method:             "GET",
		PathPattern:        "/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLabelsOK), nil

}

/*
GetLabelsID gets the label specified by ID

This endpoint let user get the label by specific ID.

*/
func (a *Client) GetLabelsID(params *GetLabelsIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetLabelsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLabelsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLabelsID",
		Method:             "GET",
		PathPattern:        "/labels/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLabelsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLabelsIDOK), nil

}

/*
GetLabelsIDResources gets the resources that the label is referenced by

This endpoint let user get the resources that the label is referenced by. Only the replication policies are returned for now.

*/
func (a *Client) GetLabelsIDResources(params *GetLabelsIDResourcesParams, authInfo runtime.ClientAuthInfoWriter) (*GetLabelsIDResourcesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLabelsIDResourcesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLabelsIDResources",
		Method:             "GET",
		PathPattern:        "/labels/{id}/resources",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLabelsIDResourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLabelsIDResourcesOK), nil

}

/*
GetLdapGroupsSearch searches available ldap groups

This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.

*/
func (a *Client) GetLdapGroupsSearch(params *GetLdapGroupsSearchParams, authInfo runtime.ClientAuthInfoWriter) (*GetLdapGroupsSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLdapGroupsSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLdapGroupsSearch",
		Method:             "GET",
		PathPattern:        "/ldap/groups/search",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLdapGroupsSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLdapGroupsSearchOK), nil

}

/*
GetLdapUsersSearch searches available ldap users

This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.

*/
func (a *Client) GetLdapUsersSearch(params *GetLdapUsersSearchParams, authInfo runtime.ClientAuthInfoWriter) (*GetLdapUsersSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLdapUsersSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLdapUsersSearch",
		Method:             "GET",
		PathPattern:        "/ldap/users/search",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLdapUsersSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLdapUsersSearchOK), nil

}

/*
GetLogs gets recent logs of the projects which the user is a member of

This endpoint let user see the recent operation logs of the projects which he is member of

*/
func (a *Client) GetLogs(params *GetLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetLogs",
		Method:             "GET",
		PathPattern:        "/logs",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogsOK), nil

}

/*
GetProjects lists projects

This endpoint returns all projects created by Harbor, and can be filtered by project name.

*/
func (a *Client) GetProjects(params *GetProjectsParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjects",
		Method:             "GET",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsOK), nil

}

/*
GetProjectsProjectID returns specific project detail information

This endpoint returns specific project information by project ID.

*/
func (a *Client) GetProjectsProjectID(params *GetProjectsProjectIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectID",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDOK), nil

}

/*
GetProjectsProjectIDLogs gets access logs accompany with a relevant project

This endpoint let user search access logs filtered by operations and date time ranges.

*/
func (a *Client) GetProjectsProjectIDLogs(params *GetProjectsProjectIDLogsParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDLogsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDLogsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDLogs",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/logs",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDLogsOK), nil

}

/*
GetProjectsProjectIDMembers gets all project member information

Get all project member information
*/
func (a *Client) GetProjectsProjectIDMembers(params *GetProjectsProjectIDMembersParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDMembersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDMembersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDMembers",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/members",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDMembersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDMembersOK), nil

}

/*
GetProjectsProjectIDMembersMid gets the project member information

Get the project member information
*/
func (a *Client) GetProjectsProjectIDMembersMid(params *GetProjectsProjectIDMembersMidParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDMembersMidOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDMembersMidParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDMembersMid",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/members/{mid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDMembersMidReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDMembersMidOK), nil

}

/*
GetProjectsProjectIDMetadatas gets project metadata

This endpoint returns metadata of the project specified by project ID.

*/
func (a *Client) GetProjectsProjectIDMetadatas(params *GetProjectsProjectIDMetadatasParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDMetadatasOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDMetadatasParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDMetadatas",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/metadatas",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDMetadatasReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDMetadatasOK), nil

}

/*
GetProjectsProjectIDMetadatasMetaName gets project metadata

This endpoint returns specified metadata of a project.

*/
func (a *Client) GetProjectsProjectIDMetadatasMetaName(params *GetProjectsProjectIDMetadatasMetaNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDMetadatasMetaNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDMetadatasMetaNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDMetadatasMetaName",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/metadatas/{meta_name}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDMetadatasMetaNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDMetadatasMetaNameOK), nil

}

/*
GetProjectsProjectIDSummary gets summary of the project

Get summary of the project.
*/
func (a *Client) GetProjectsProjectIDSummary(params *GetProjectsProjectIDSummaryParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDSummaryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDSummaryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDSummary",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/summary",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDSummaryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDSummaryOK), nil

}

/*
GetProjectsProjectIDWebhookJobs lists project webhook jobs

This endpoint returns webhook jobs of a project.

*/
func (a *Client) GetProjectsProjectIDWebhookJobs(params *GetProjectsProjectIDWebhookJobsParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDWebhookJobsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDWebhookJobsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDWebhookJobs",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/webhook/jobs",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDWebhookJobsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDWebhookJobsOK), nil

}

/*
GetProjectsProjectIDWebhookLasttrigger gets project webhook policy last trigger info

This endpoint returns last trigger information of project webhook policy.

*/
func (a *Client) GetProjectsProjectIDWebhookLasttrigger(params *GetProjectsProjectIDWebhookLasttriggerParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDWebhookLasttriggerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDWebhookLasttriggerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDWebhookLasttrigger",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/webhook/lasttrigger",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDWebhookLasttriggerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDWebhookLasttriggerOK), nil

}

/*
GetProjectsProjectIDWebhookPolicies lists project webhook policies

This endpoint returns webhook policies of a project.

*/
func (a *Client) GetProjectsProjectIDWebhookPolicies(params *GetProjectsProjectIDWebhookPoliciesParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDWebhookPoliciesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDWebhookPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDWebhookPolicies",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/webhook/policies",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDWebhookPoliciesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDWebhookPoliciesOK), nil

}

/*
GetProjectsProjectIDWebhookPoliciesPolicyID gets project webhook policy

This endpoint returns specified webhook policy of a project.

*/
func (a *Client) GetProjectsProjectIDWebhookPoliciesPolicyID(params *GetProjectsProjectIDWebhookPoliciesPolicyIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetProjectsProjectIDWebhookPoliciesPolicyIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetProjectsProjectIDWebhookPoliciesPolicyIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetProjectsProjectIDWebhookPoliciesPolicyID",
		Method:             "GET",
		PathPattern:        "/projects/{project_id}/webhook/policies/{policy_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectsProjectIDWebhookPoliciesPolicyIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetProjectsProjectIDWebhookPoliciesPolicyIDOK), nil

}

/*
GetRegistries lists registries

This endpoint let user list filtered registries by name, if name is nil, list returns all registries.

*/
func (a *Client) GetRegistries(params *GetRegistriesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRegistriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRegistries",
		Method:             "GET",
		PathPattern:        "/registries",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRegistriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRegistriesOK), nil

}

/*
GetRegistriesID gets registry

This endpoint is for get specific registry.
*/
func (a *Client) GetRegistriesID(params *GetRegistriesIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetRegistriesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistriesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRegistriesID",
		Method:             "GET",
		PathPattern:        "/registries/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRegistriesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRegistriesIDOK), nil

}

/*
GetRegistriesIDInfo gets registry info

Get the info of one specific registry.
*/
func (a *Client) GetRegistriesIDInfo(params *GetRegistriesIDInfoParams, authInfo runtime.ClientAuthInfoWriter) (*GetRegistriesIDInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistriesIDInfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRegistriesIDInfo",
		Method:             "GET",
		PathPattern:        "/registries/{id}/info",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRegistriesIDInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRegistriesIDInfoOK), nil

}

/*
GetRegistriesIDNamespace lists namespaces of registry

This endpoint let user list namespaces of registry according to query.

*/
func (a *Client) GetRegistriesIDNamespace(params *GetRegistriesIDNamespaceParams, authInfo runtime.ClientAuthInfoWriter) (*GetRegistriesIDNamespaceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRegistriesIDNamespaceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRegistriesIDNamespace",
		Method:             "GET",
		PathPattern:        "/registries/{id}/namespace",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRegistriesIDNamespaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRegistriesIDNamespaceOK), nil

}

/*
GetReplicationAdapters lists supported adapters

This endpoint let user list supported adapters.

*/
func (a *Client) GetReplicationAdapters(params *GetReplicationAdaptersParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationAdaptersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationAdaptersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationAdapters",
		Method:             "GET",
		PathPattern:        "/replication/adapters",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationAdaptersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationAdaptersOK), nil

}

/*
GetReplicationExecutions lists replication executions

This endpoint let user list replication executions.

*/
func (a *Client) GetReplicationExecutions(params *GetReplicationExecutionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationExecutionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationExecutionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationExecutions",
		Method:             "GET",
		PathPattern:        "/replication/executions",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationExecutionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationExecutionsOK), nil

}

/*
GetReplicationExecutionsID gets the execution of the replication

This endpoint is for user to get one execution of the replication.

*/
func (a *Client) GetReplicationExecutionsID(params *GetReplicationExecutionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationExecutionsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationExecutionsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationExecutionsID",
		Method:             "GET",
		PathPattern:        "/replication/executions/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationExecutionsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationExecutionsIDOK), nil

}

/*
GetReplicationExecutionsIDTasks gets the task list of one execution

This endpoint is for user to get the task list of one execution.

*/
func (a *Client) GetReplicationExecutionsIDTasks(params *GetReplicationExecutionsIDTasksParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationExecutionsIDTasksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationExecutionsIDTasksParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationExecutionsIDTasks",
		Method:             "GET",
		PathPattern:        "/replication/executions/{id}/tasks",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationExecutionsIDTasksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationExecutionsIDTasksOK), nil

}

/*
GetReplicationExecutionsIDTasksTaskIDLog gets the log of one task

This endpoint is for user to get the log of one task.

*/
func (a *Client) GetReplicationExecutionsIDTasksTaskIDLog(params *GetReplicationExecutionsIDTasksTaskIDLogParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationExecutionsIDTasksTaskIDLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationExecutionsIDTasksTaskIDLogParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationExecutionsIDTasksTaskIDLog",
		Method:             "GET",
		PathPattern:        "/replication/executions/{id}/tasks/{task_id}/log",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationExecutionsIDTasksTaskIDLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationExecutionsIDTasksTaskIDLogOK), nil

}

/*
GetReplicationPolicies lists replication policies

This endpoint let user list replication policies

*/
func (a *Client) GetReplicationPolicies(params *GetReplicationPoliciesParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationPoliciesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationPolicies",
		Method:             "GET",
		PathPattern:        "/replication/policies",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationPoliciesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationPoliciesOK), nil

}

/*
GetReplicationPoliciesID gets replication policy

This endpoint let user get replication policy by specific ID.

*/
func (a *Client) GetReplicationPoliciesID(params *GetReplicationPoliciesIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetReplicationPoliciesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetReplicationPoliciesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetReplicationPoliciesID",
		Method:             "GET",
		PathPattern:        "/replication/policies/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetReplicationPoliciesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetReplicationPoliciesIDOK), nil

}

/*
GetRepositories gets repositories accompany with relevant project and repo name

This endpoint lets user search repositories accompanying with relevant project ID and repo name. Repositories can be sorted by repo name, creation_time, update_time in either ascending or descending order.

*/
func (a *Client) GetRepositories(params *GetRepositoriesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositories",
		Method:             "GET",
		PathPattern:        "/repositories",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesOK), nil

}

/*
GetRepositoriesRepoNameLabels gets labels of a repository

Get labels of a repository specified by the repo_name.

*/
func (a *Client) GetRepositoriesRepoNameLabels(params *GetRepositoriesRepoNameLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameLabelsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameLabels",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameLabelsOK), nil

}

/*
GetRepositoriesRepoNameSignatures gets signature information of a repository

This endpoint aims to retrieve signature information of a repository, the data is
from the nested notary instance of Harbor.
If the repository does not have any signature information in notary, this API will
return an empty list with response code 200, instead of 404

*/
func (a *Client) GetRepositoriesRepoNameSignatures(params *GetRepositoriesRepoNameSignaturesParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameSignaturesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameSignaturesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameSignatures",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/signatures",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameSignaturesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameSignaturesOK), nil

}

/*
GetRepositoriesRepoNameTags gets tags of a relevant repository

This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.

*/
func (a *Client) GetRepositoriesRepoNameTags(params *GetRepositoriesRepoNameTagsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameTagsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameTagsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameTags",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/tags",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameTagsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameTagsOK), nil

}

/*
GetRepositoriesRepoNameTagsTag gets the tag of the repository

This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.

*/
func (a *Client) GetRepositoriesRepoNameTagsTag(params *GetRepositoriesRepoNameTagsTagParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameTagsTagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameTagsTagParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameTagsTag",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameTagsTagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameTagsTagOK), nil

}

/*
GetRepositoriesRepoNameTagsTagLabels gets labels of an image

Get labels of an image specified by the repo_name and tag.

*/
func (a *Client) GetRepositoriesRepoNameTagsTagLabels(params *GetRepositoriesRepoNameTagsTagLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameTagsTagLabelsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameTagsTagLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameTagsTagLabels",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameTagsTagLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameTagsTagLabelsOK), nil

}

/*
GetRepositoriesRepoNameTagsTagManifest gets manifests of a relevant repository

This endpoint aims to retreive manifests from a relevant repository.

*/
func (a *Client) GetRepositoriesRepoNameTagsTagManifest(params *GetRepositoriesRepoNameTagsTagManifestParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameTagsTagManifestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameTagsTagManifestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameTagsTagManifest",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/manifest",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameTagsTagManifestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameTagsTagManifestOK), nil

}

/*
GetRepositoriesRepoNameTagsTagVulnerabilityDetails gets vulnerability details of the image

Call Clair API to get the vulnerability based on the previous successful scan.

*/
func (a *Client) GetRepositoriesRepoNameTagsTagVulnerabilityDetails(params *GetRepositoriesRepoNameTagsTagVulnerabilityDetailsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesRepoNameTagsTagVulnerabilityDetailsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesRepoNameTagsTagVulnerabilityDetailsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesRepoNameTagsTagVulnerabilityDetails",
		Method:             "GET",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/vulnerability/details",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesRepoNameTagsTagVulnerabilityDetailsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesRepoNameTagsTagVulnerabilityDetailsOK), nil

}

/*
GetRepositoriesTop gets public repositories which are accessed most

This endpoint aims to let users see the most popular public repositories

*/
func (a *Client) GetRepositoriesTop(params *GetRepositoriesTopParams, authInfo runtime.ClientAuthInfoWriter) (*GetRepositoriesTopOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRepositoriesTopParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetRepositoriesTop",
		Method:             "GET",
		PathPattern:        "/repositories/top",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRepositoriesTopReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRepositoriesTopOK), nil

}

/*
GetSearch searches for projects repositories and helm charts

The Search endpoint returns information about the projects ,repositories  and helm charts offered at public status or related to the current logged in user. The response includes the project, repository list and charts in a proper display order.

*/
func (a *Client) GetSearch(params *GetSearchParams, authInfo runtime.ClientAuthInfoWriter) (*GetSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSearch",
		Method:             "GET",
		PathPattern:        "/search",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSearchOK), nil

}

/*
GetStatistics gets projects number and repositories number relevant to the user

This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number.

*/
func (a *Client) GetStatistics(params *GetStatisticsParams, authInfo runtime.ClientAuthInfoWriter) (*GetStatisticsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetStatisticsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetStatistics",
		Method:             "GET",
		PathPattern:        "/statistics",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetStatisticsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetStatisticsOK), nil

}

/*
GetSystemGc gets gc results

This endpoint let user get latest ten gc results.
*/
func (a *Client) GetSystemGc(params *GetSystemGcParams, authInfo runtime.ClientAuthInfoWriter) (*GetSystemGcOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemGcParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSystemGc",
		Method:             "GET",
		PathPattern:        "/system/gc",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemGcReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSystemGcOK), nil

}

/*
GetSystemGcID gets gc status

This endpoint let user get gc status filtered by specific ID.
*/
func (a *Client) GetSystemGcID(params *GetSystemGcIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetSystemGcIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemGcIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSystemGcID",
		Method:             "GET",
		PathPattern:        "/system/gc/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemGcIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSystemGcIDOK), nil

}

/*
GetSystemGcIDLog gets gc job log

This endpoint let user get gc job logs filtered by specific ID.
*/
func (a *Client) GetSystemGcIDLog(params *GetSystemGcIDLogParams, authInfo runtime.ClientAuthInfoWriter) (*GetSystemGcIDLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemGcIDLogParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSystemGcIDLog",
		Method:             "GET",
		PathPattern:        "/system/gc/{id}/log",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemGcIDLogReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSystemGcIDLogOK), nil

}

/*
GetSystemGcSchedule gets gc s schedule

This endpoint is for get schedule of gc job.
*/
func (a *Client) GetSystemGcSchedule(params *GetSystemGcScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*GetSystemGcScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemGcScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSystemGcSchedule",
		Method:             "GET",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemGcScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSystemGcScheduleOK), nil

}

/*
GetSystemScanAllSchedule gets scan all s schedule

This endpoint is for getting a schedule for the scan all job, which scans all of images in Harbor.
*/
func (a *Client) GetSystemScanAllSchedule(params *GetSystemScanAllScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*GetSystemScanAllScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSystemScanAllScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSystemScanAllSchedule",
		Method:             "GET",
		PathPattern:        "/system/scanAll/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSystemScanAllScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSystemScanAllScheduleOK), nil

}

/*
GetSysteminfo gets general system info

This API is for retrieving general system info, this can be called by anonymous request.

*/
func (a *Client) GetSysteminfo(params *GetSysteminfoParams, authInfo runtime.ClientAuthInfoWriter) (*GetSysteminfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSysteminfoParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSysteminfo",
		Method:             "GET",
		PathPattern:        "/systeminfo",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSysteminfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSysteminfoOK), nil

}

/*
GetSysteminfoGetcert gets default root certificate

This endpoint is for downloading a default root certificate.

*/
func (a *Client) GetSysteminfoGetcert(params *GetSysteminfoGetcertParams, authInfo runtime.ClientAuthInfoWriter) (*GetSysteminfoGetcertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSysteminfoGetcertParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSysteminfoGetcert",
		Method:             "GET",
		PathPattern:        "/systeminfo/getcert",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSysteminfoGetcertReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSysteminfoGetcertOK), nil

}

/*
GetSysteminfoVolumes gets system volume info total free size

This endpoint is for retrieving system volume info that only provides for admin user.

*/
func (a *Client) GetSysteminfoVolumes(params *GetSysteminfoVolumesParams, authInfo runtime.ClientAuthInfoWriter) (*GetSysteminfoVolumesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSysteminfoVolumesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSysteminfoVolumes",
		Method:             "GET",
		PathPattern:        "/systeminfo/volumes",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSysteminfoVolumesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSysteminfoVolumesOK), nil

}

/*
GetUsergroups gets all user groups information

Get all user groups information
*/
func (a *Client) GetUsergroups(params *GetUsergroupsParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsergroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsergroupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsergroups",
		Method:             "GET",
		PathPattern:        "/usergroups",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsergroupsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsergroupsOK), nil

}

/*
GetUsergroupsGroupID gets user group information

Get user group information
*/
func (a *Client) GetUsergroupsGroupID(params *GetUsergroupsGroupIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsergroupsGroupIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsergroupsGroupIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsergroupsGroupID",
		Method:             "GET",
		PathPattern:        "/usergroups/{group_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsergroupsGroupIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsergroupsGroupIDOK), nil

}

/*
GetUsers gets registered users of harbor

This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator.

*/
func (a *Client) GetUsers(params *GetUsersParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsers",
		Method:             "GET",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersOK), nil

}

/*
GetUsersCurrent gets current user info

This endpoint is to get the current user information.

*/
func (a *Client) GetUsersCurrent(params *GetUsersCurrentParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersCurrentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersCurrentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsersCurrent",
		Method:             "GET",
		PathPattern:        "/users/current",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsersCurrentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersCurrentOK), nil

}

/*
GetUsersCurrentPermissions gets current user permissions

This endpoint is to get the current user permissions.

*/
func (a *Client) GetUsersCurrentPermissions(params *GetUsersCurrentPermissionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersCurrentPermissionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersCurrentPermissionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsersCurrentPermissions",
		Method:             "GET",
		PathPattern:        "/users/current/permissions",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsersCurrentPermissionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersCurrentPermissionsOK), nil

}

/*
GetUsersSearch searches users by username email

This endpoint is to search the users by username, email.

*/
func (a *Client) GetUsersSearch(params *GetUsersSearchParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsersSearch",
		Method:             "GET",
		PathPattern:        "/users/search",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsersSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersSearchOK), nil

}

/*
GetUsersUserID gets a user s profile

Get user's profile with user id.

*/
func (a *Client) GetUsersUserID(params *GetUsersUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*GetUsersUserIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUsersUserIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetUsersUserID",
		Method:             "GET",
		PathPattern:        "/users/{user_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetUsersUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUsersUserIDOK), nil

}

/*
HeadProjects checks if the project name user provided already exists

This endpoint is used to check if the project name user provided already exist.

*/
func (a *Client) HeadProjects(params *HeadProjectsParams, authInfo runtime.ClientAuthInfoWriter) (*HeadProjectsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeadProjectsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "HeadProjects",
		Method:             "HEAD",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeadProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*HeadProjectsOK), nil

}

/*
PostEmailPing tests connection and authentication with email server

Test connection and authentication with email server.

*/
func (a *Client) PostEmailPing(params *PostEmailPingParams, authInfo runtime.ClientAuthInfoWriter) (*PostEmailPingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostEmailPingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostEmailPing",
		Method:             "POST",
		PathPattern:        "/email/ping",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostEmailPingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostEmailPingOK), nil

}

/*
PostInternalSyncregistry syncs repositories from registry to d b

This endpoint is for syncing all repositories of registry with database.

*/
func (a *Client) PostInternalSyncregistry(params *PostInternalSyncregistryParams, authInfo runtime.ClientAuthInfoWriter) (*PostInternalSyncregistryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostInternalSyncregistryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostInternalSyncregistry",
		Method:             "POST",
		PathPattern:        "/internal/syncregistry",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostInternalSyncregistryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostInternalSyncregistryOK), nil

}

/*
PostLabels posts creates a label

This endpoint let user creates a label.

*/
func (a *Client) PostLabels(params *PostLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*PostLabelsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostLabels",
		Method:             "POST",
		PathPattern:        "/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostLabelsCreated), nil

}

/*
PostLdapPing pings available ldap service

This endpoint ping the available ldap service for test related configuration parameters.

*/
func (a *Client) PostLdapPing(params *PostLdapPingParams, authInfo runtime.ClientAuthInfoWriter) (*PostLdapPingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostLdapPingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostLdapPing",
		Method:             "POST",
		PathPattern:        "/ldap/ping",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostLdapPingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostLdapPingOK), nil

}

/*
PostLdapUsersImport imports selected available ldap users

This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information.
If have errors when import user, will return the list of importing failed uid and the failed reason.

*/
func (a *Client) PostLdapUsersImport(params *PostLdapUsersImportParams, authInfo runtime.ClientAuthInfoWriter) (*PostLdapUsersImportOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostLdapUsersImportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostLdapUsersImport",
		Method:             "POST",
		PathPattern:        "/ldap/users/import",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostLdapUsersImportReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostLdapUsersImportOK), nil

}

/*
PostProjects creates a new project

This endpoint is for user to create a new project.

*/
func (a *Client) PostProjects(params *PostProjectsParams, authInfo runtime.ClientAuthInfoWriter) (*PostProjectsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProjectsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostProjects",
		Method:             "POST",
		PathPattern:        "/projects",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProjectsCreated), nil

}

/*
PostProjectsProjectIDMembers creates project member

Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.
*/
func (a *Client) PostProjectsProjectIDMembers(params *PostProjectsProjectIDMembersParams, authInfo runtime.ClientAuthInfoWriter) (*PostProjectsProjectIDMembersCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProjectsProjectIDMembersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostProjectsProjectIDMembers",
		Method:             "POST",
		PathPattern:        "/projects/{project_id}/members",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostProjectsProjectIDMembersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProjectsProjectIDMembersCreated), nil

}

/*
PostProjectsProjectIDMetadatas adds metadata for the project

This endpoint is aimed to add metadata of a project.

*/
func (a *Client) PostProjectsProjectIDMetadatas(params *PostProjectsProjectIDMetadatasParams, authInfo runtime.ClientAuthInfoWriter) (*PostProjectsProjectIDMetadatasOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProjectsProjectIDMetadatasParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostProjectsProjectIDMetadatas",
		Method:             "POST",
		PathPattern:        "/projects/{project_id}/metadatas",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostProjectsProjectIDMetadatasReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProjectsProjectIDMetadatasOK), nil

}

/*
PostProjectsProjectIDWebhookPolicies creates project webhook policy

This endpoint create a webhook policy if the project does not have one.

*/
func (a *Client) PostProjectsProjectIDWebhookPolicies(params *PostProjectsProjectIDWebhookPoliciesParams, authInfo runtime.ClientAuthInfoWriter) (*PostProjectsProjectIDWebhookPoliciesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProjectsProjectIDWebhookPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostProjectsProjectIDWebhookPolicies",
		Method:             "POST",
		PathPattern:        "/projects/{project_id}/webhook/policies",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostProjectsProjectIDWebhookPoliciesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProjectsProjectIDWebhookPoliciesCreated), nil

}

/*
PostProjectsProjectIDWebhookPoliciesTest tests project webhook connection

This endpoint tests webhook connection of a project.

*/
func (a *Client) PostProjectsProjectIDWebhookPoliciesTest(params *PostProjectsProjectIDWebhookPoliciesTestParams, authInfo runtime.ClientAuthInfoWriter) (*PostProjectsProjectIDWebhookPoliciesTestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostProjectsProjectIDWebhookPoliciesTestParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostProjectsProjectIDWebhookPoliciesTest",
		Method:             "POST",
		PathPattern:        "/projects/{project_id}/webhook/policies/test",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostProjectsProjectIDWebhookPoliciesTestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostProjectsProjectIDWebhookPoliciesTestOK), nil

}

/*
PostRegistries creates a new registry

This endpoint is for user to create a new registry.

*/
func (a *Client) PostRegistries(params *PostRegistriesParams, authInfo runtime.ClientAuthInfoWriter) (*PostRegistriesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRegistriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRegistries",
		Method:             "POST",
		PathPattern:        "/registries",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRegistriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRegistriesCreated), nil

}

/*
PostRegistriesPing pings status of a registry

This endpoint checks status of a registry, the registry can be given by ID or URL (together with credential)

*/
func (a *Client) PostRegistriesPing(params *PostRegistriesPingParams, authInfo runtime.ClientAuthInfoWriter) (*PostRegistriesPingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRegistriesPingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRegistriesPing",
		Method:             "POST",
		PathPattern:        "/registries/ping",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRegistriesPingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRegistriesPingOK), nil

}

/*
PostReplicationExecutions starts one execution of the replication

This endpoint is for user to start one execution of the replication.

*/
func (a *Client) PostReplicationExecutions(params *PostReplicationExecutionsParams, authInfo runtime.ClientAuthInfoWriter) (*PostReplicationExecutionsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostReplicationExecutionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostReplicationExecutions",
		Method:             "POST",
		PathPattern:        "/replication/executions",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostReplicationExecutionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostReplicationExecutionsCreated), nil

}

/*
PostReplicationPolicies creates a replication policy

This endpoint let user create a replication policy

*/
func (a *Client) PostReplicationPolicies(params *PostReplicationPoliciesParams, authInfo runtime.ClientAuthInfoWriter) (*PostReplicationPoliciesCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostReplicationPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostReplicationPolicies",
		Method:             "POST",
		PathPattern:        "/replication/policies",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostReplicationPoliciesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostReplicationPoliciesCreated), nil

}

/*
PostRepositoriesRepoNameLabels adds a label to the repository

Add a label to the repository.

*/
func (a *Client) PostRepositoriesRepoNameLabels(params *PostRepositoriesRepoNameLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesRepoNameLabelsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesRepoNameLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesRepoNameLabels",
		Method:             "POST",
		PathPattern:        "/repositories/{repo_name}/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRepositoriesRepoNameLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRepositoriesRepoNameLabelsOK), nil

}

/*
PostRepositoriesRepoNameTags retags an image

This endpoint tags an existing image with another tag in this repo, source images can be in different repos or projects.

*/
func (a *Client) PostRepositoriesRepoNameTags(params *PostRepositoriesRepoNameTagsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesRepoNameTagsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesRepoNameTagsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesRepoNameTags",
		Method:             "POST",
		PathPattern:        "/repositories/{repo_name}/tags",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRepositoriesRepoNameTagsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRepositoriesRepoNameTagsOK), nil

}

/*
PostRepositoriesRepoNameTagsTagLabels adds a label to image

Add a label to the image.

*/
func (a *Client) PostRepositoriesRepoNameTagsTagLabels(params *PostRepositoriesRepoNameTagsTagLabelsParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesRepoNameTagsTagLabelsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesRepoNameTagsTagLabelsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesRepoNameTagsTagLabels",
		Method:             "POST",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/labels",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRepositoriesRepoNameTagsTagLabelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRepositoriesRepoNameTagsTagLabelsOK), nil

}

/*
PostRepositoriesRepoNameTagsTagScan scans the image

Trigger jobservice to call Clair API to scan the image identified by the repo_name and tag.  Only project admins have permission to scan images under the project.

*/
func (a *Client) PostRepositoriesRepoNameTagsTagScan(params *PostRepositoriesRepoNameTagsTagScanParams, authInfo runtime.ClientAuthInfoWriter) (*PostRepositoriesRepoNameTagsTagScanOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostRepositoriesRepoNameTagsTagScanParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostRepositoriesRepoNameTagsTagScan",
		Method:             "POST",
		PathPattern:        "/repositories/{repo_name}/tags/{tag}/scan",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostRepositoriesRepoNameTagsTagScanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRepositoriesRepoNameTagsTagScanOK), nil

}

/*
PostSystemGcSchedule creates a gc schedule

This endpoint is for update gc schedule.

*/
func (a *Client) PostSystemGcSchedule(params *PostSystemGcScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*PostSystemGcScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostSystemGcScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostSystemGcSchedule",
		Method:             "POST",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostSystemGcScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostSystemGcScheduleOK), nil

}

/*
PostSystemScanAllSchedule creates a schedule or a manual trigger for the scan all job

This endpoint is for creating a schedule or a manual trigger for the scan all job, which scans all of images in Harbor.

*/
func (a *Client) PostSystemScanAllSchedule(params *PostSystemScanAllScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*PostSystemScanAllScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostSystemScanAllScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostSystemScanAllSchedule",
		Method:             "POST",
		PathPattern:        "/system/scanAll/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostSystemScanAllScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostSystemScanAllScheduleOK), nil

}

/*
PostUsergroups creates user group

Create user group information
*/
func (a *Client) PostUsergroups(params *PostUsergroupsParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsergroupsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsergroupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostUsergroups",
		Method:             "POST",
		PathPattern:        "/usergroups",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostUsergroupsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostUsergroupsCreated), nil

}

/*
PostUsers creates a new user account

This endpoint is to create a user if the user does not already exist.

*/
func (a *Client) PostUsers(params *PostUsersParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsersCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostUsers",
		Method:             "POST",
		PathPattern:        "/users",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostUsersCreated), nil

}

/*
PostUsersUserIDGenCliSecret generates new c l i secret for a user

This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'.
Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret
for a user.  The new secret will be returned in the response.

*/
func (a *Client) PostUsersUserIDGenCliSecret(params *PostUsersUserIDGenCliSecretParams, authInfo runtime.ClientAuthInfoWriter) (*PostUsersUserIDGenCliSecretOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostUsersUserIDGenCliSecretParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PostUsersUserIDGenCliSecret",
		Method:             "POST",
		PathPattern:        "/users/{user_id}/gen_cli_secret",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostUsersUserIDGenCliSecretReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostUsersUserIDGenCliSecretOK), nil

}

/*
PutConfigurations modifies system configurations

This endpoint is for modifying system configurations that only provides for admin user.

*/
func (a *Client) PutConfigurations(params *PutConfigurationsParams, authInfo runtime.ClientAuthInfoWriter) (*PutConfigurationsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutConfigurationsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutConfigurations",
		Method:             "PUT",
		PathPattern:        "/configurations",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutConfigurationsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConfigurationsOK), nil

}

/*
PutLabelsID updates the label properties

This endpoint let user update label properties.

*/
func (a *Client) PutLabelsID(params *PutLabelsIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutLabelsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutLabelsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutLabelsID",
		Method:             "PUT",
		PathPattern:        "/labels/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutLabelsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutLabelsIDOK), nil

}

/*
PutProjectsProjectID updates properties for a selected project

This endpoint is aimed to update the properties of a project.

*/
func (a *Client) PutProjectsProjectID(params *PutProjectsProjectIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutProjectsProjectIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutProjectsProjectIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutProjectsProjectID",
		Method:             "PUT",
		PathPattern:        "/projects/{project_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutProjectsProjectIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutProjectsProjectIDOK), nil

}

/*
PutProjectsProjectIDMembersMid updates project member

Update project member relationship
*/
func (a *Client) PutProjectsProjectIDMembersMid(params *PutProjectsProjectIDMembersMidParams, authInfo runtime.ClientAuthInfoWriter) (*PutProjectsProjectIDMembersMidOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutProjectsProjectIDMembersMidParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutProjectsProjectIDMembersMid",
		Method:             "PUT",
		PathPattern:        "/projects/{project_id}/members/{mid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutProjectsProjectIDMembersMidReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutProjectsProjectIDMembersMidOK), nil

}

/*
PutProjectsProjectIDMetadatasMetaName updates metadata of a project

This endpoint is aimed to update the metadata of a project.

*/
func (a *Client) PutProjectsProjectIDMetadatasMetaName(params *PutProjectsProjectIDMetadatasMetaNameParams, authInfo runtime.ClientAuthInfoWriter) (*PutProjectsProjectIDMetadatasMetaNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutProjectsProjectIDMetadatasMetaNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutProjectsProjectIDMetadatasMetaName",
		Method:             "PUT",
		PathPattern:        "/projects/{project_id}/metadatas/{meta_name}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutProjectsProjectIDMetadatasMetaNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutProjectsProjectIDMetadatasMetaNameOK), nil

}

/*
PutProjectsProjectIDWebhookPoliciesPolicyID updates webhook policy of a project

This endpoint is aimed to update the webhook policy of a project.

*/
func (a *Client) PutProjectsProjectIDWebhookPoliciesPolicyID(params *PutProjectsProjectIDWebhookPoliciesPolicyIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutProjectsProjectIDWebhookPoliciesPolicyIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutProjectsProjectIDWebhookPoliciesPolicyIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutProjectsProjectIDWebhookPoliciesPolicyID",
		Method:             "PUT",
		PathPattern:        "/projects/{project_id}/webhook/policies/{policy_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutProjectsProjectIDWebhookPoliciesPolicyIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutProjectsProjectIDWebhookPoliciesPolicyIDOK), nil

}

/*
PutRegistriesID updates a given registry

This endpoint is for update a given registry.

*/
func (a *Client) PutRegistriesID(params *PutRegistriesIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutRegistriesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutRegistriesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutRegistriesID",
		Method:             "PUT",
		PathPattern:        "/registries/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutRegistriesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRegistriesIDOK), nil

}

/*
PutReplicationExecutionsID stops the execution of the replication

This endpoint is for user to stop one execution of the replication.

*/
func (a *Client) PutReplicationExecutionsID(params *PutReplicationExecutionsIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutReplicationExecutionsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutReplicationExecutionsIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutReplicationExecutionsID",
		Method:             "PUT",
		PathPattern:        "/replication/executions/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutReplicationExecutionsIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutReplicationExecutionsIDOK), nil

}

/*
PutReplicationPoliciesID updates the replication policy

This endpoint let user update policy.

*/
func (a *Client) PutReplicationPoliciesID(params *PutReplicationPoliciesIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutReplicationPoliciesIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutReplicationPoliciesIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutReplicationPoliciesID",
		Method:             "PUT",
		PathPattern:        "/replication/policies/{id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutReplicationPoliciesIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutReplicationPoliciesIDOK), nil

}

/*
PutRepositoriesRepoName updates description of the repository

This endpoint is used to update description of the repository.

*/
func (a *Client) PutRepositoriesRepoName(params *PutRepositoriesRepoNameParams, authInfo runtime.ClientAuthInfoWriter) (*PutRepositoriesRepoNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutRepositoriesRepoNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutRepositoriesRepoName",
		Method:             "PUT",
		PathPattern:        "/repositories/{repo_name}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutRepositoriesRepoNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRepositoriesRepoNameOK), nil

}

/*
PutSystemGcSchedule updates gc s schedule

This endpoint is for update gc schedule.

*/
func (a *Client) PutSystemGcSchedule(params *PutSystemGcScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*PutSystemGcScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutSystemGcScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutSystemGcSchedule",
		Method:             "PUT",
		PathPattern:        "/system/gc/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutSystemGcScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutSystemGcScheduleOK), nil

}

/*
PutSystemScanAllSchedule updates scan all s schedule

This endpoint is for updating the schedule of scan all job, which scans all of images in Harbor.

*/
func (a *Client) PutSystemScanAllSchedule(params *PutSystemScanAllScheduleParams, authInfo runtime.ClientAuthInfoWriter) (*PutSystemScanAllScheduleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutSystemScanAllScheduleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutSystemScanAllSchedule",
		Method:             "PUT",
		PathPattern:        "/system/scanAll/schedule",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutSystemScanAllScheduleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutSystemScanAllScheduleOK), nil

}

/*
PutUsergroupsGroupID updates group information

Update user group information
*/
func (a *Client) PutUsergroupsGroupID(params *PutUsergroupsGroupIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutUsergroupsGroupIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutUsergroupsGroupIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutUsergroupsGroupID",
		Method:             "PUT",
		PathPattern:        "/usergroups/{group_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutUsergroupsGroupIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutUsergroupsGroupIDOK), nil

}

/*
PutUsersUserID updates a registered user to change his profile

This endpoint let a registered user change his profile.

*/
func (a *Client) PutUsersUserID(params *PutUsersUserIDParams, authInfo runtime.ClientAuthInfoWriter) (*PutUsersUserIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutUsersUserIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutUsersUserID",
		Method:             "PUT",
		PathPattern:        "/users/{user_id}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutUsersUserIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutUsersUserIDOK), nil

}

/*
PutUsersUserIDPassword changes the password on a user that already exists

This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password.

*/
func (a *Client) PutUsersUserIDPassword(params *PutUsersUserIDPasswordParams, authInfo runtime.ClientAuthInfoWriter) (*PutUsersUserIDPasswordOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutUsersUserIDPasswordParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutUsersUserIDPassword",
		Method:             "PUT",
		PathPattern:        "/users/{user_id}/password",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutUsersUserIDPasswordReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutUsersUserIDPasswordOK), nil

}

/*
PutUsersUserIDSysadmin updates a registered user to change to be an administrator of harbor

This endpoint let a registered user change to be an administrator
of Harbor.

*/
func (a *Client) PutUsersUserIDSysadmin(params *PutUsersUserIDSysadminParams, authInfo runtime.ClientAuthInfoWriter) (*PutUsersUserIDSysadminOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutUsersUserIDSysadminParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PutUsersUserIDSysadmin",
		Method:             "PUT",
		PathPattern:        "/users/{user_id}/sysadmin",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PutUsersUserIDSysadminReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutUsersUserIDSysadminOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
